#!/usr/bin/env python
"""
Name :          supercli/autocomplete.py
Created :       Sept 04 2016
Author :        Will Pittman
Contact :       willjpittman@gmail.com
________________________________________________________________________________
Description :   Autocompletion script-generators for various
                languages.
________________________________________________________________________________
"""
## builtin
from   __future__    import unicode_literals
from   __future__    import absolute_import
from   subprocess    import PIPE
import subprocess
import logging
import datetime
import os
import sys
import six
## custom
import supercli.argparse

logger = logging.getLogger(__name__)
loc    = locals


class ZshCompleter(object):
    def __init__(self,parser,cli_command):
        ## Attributes
        self.parser         = parser
        self.subparsers_obj = parser.subparsers_obj
        self.cli_command    = cli_command


        self._validate_args()

    def _validate_args(self):
        """
        Ensures arguments will not break Execution
        """


        parser         = self.parser
        subparsers_obj = self.subparsers_obj
        cli_command    = self.cli_command

        if not isinstance( parser, supercli.argparse.ArgumentParser ):
            raise TypeError(
                "`parser` argument must be an instance of `ReadableArgumentParser`\n"
                "(additional attrs/methods added to retrieve info from parser/subparsers) \n"
            )
        #if not isinstance( cli_command, basestring ):
        #    raise TypeError(
        #        "`cli_command` must be in the form of a string. It references the CLI command that is being completed"
        #    )
        #if not any([ subparsers_obj==None, isinstace( subparsers_obj, supercli.argparse_SubparsersProxy )]):
        #    raise TypeError(
        #        "subparsers_obj attribute must be either Nonetype or an instance of ReadableArgumentParser_SubparsersProxy"
        #    )


    def get(self):
        """
        Generates and returns text for a complete zsh autocompletion script
        """
        parser  = self.parser
        comptxt = ''

        subparsers = self._get_subparsers()


        if subparsers:
            comptxt = self._get_comptxt_w_subparsers(subparsers)
        else:
            comptxt = self._get_comptxt_no_subparsers(parser)

        return comptxt

    def _get_subparsers(self):
        """
        Builds a dictionary of subparsers.

        ___________________________________________________________________
        OUTPUT:
        ___________________________________________________________________
            subparsers = {
                'display' : {
                                'title'    : 'display',
                                'help'     : 'commands related to displaying wallpapers',
                                'instance' : <subparser instance>,
                            }
                ...
                }
        """
        subparsers     = {}
        parser         = self.parser
        subparsers_obj = self.subparsers_obj


        if parser.subparsers_obj:
            for subparser in subparsers_obj.get_subparsers():
                info = subparser.get_info()
                subparsers[ info['title'] ] = info

        return subparsers

    def _get_comptxt_header(self):

        cli_command = self.cli_command

        now    = datetime.datetime.now()
        nowstr = now.strftime('%b %d %Y')

        comptxt = (
            '#compdef %(cli_command)s                                                                    \n'
            '########################################################################################### \n'
            '# Name :          _%(cli_command)s                                                          \n'
            '# Created :       %(nowstr)s                                                                \n'
            '# Generated By:   supercli.autocomplete.py                                                  \n'
            '#_________________________________________________________________________________________  \n'
            '# Description :   ZSH autocompletion script for CLI command: "%(cli_command)s".             \n'
            '#                                                                                           \n'
            '#                 To enabe autocompletion in zsh, add the following lines                   \n'
            '#                 to your ~/.zshrc file:                                                    \n'
            '#                                                                                           \n'
            '#                      autoload -U compinit                                                 \n'
            '#                      compinit                                                             \n'
            '#                                                                                           \n'
            '#                 To use this script, copy it to a location on your $fpath                  \n'
            '#                 then open a new terminal or ZSH process.                                  \n'
            '#                 (ex: /usr/share/zsh/functions/Completion/Unix/ )                          \n'
            '#_________________________________________________________________________________________  \n'
            '########################################################################################### \n'
            '                                                                                            \n'
        ) % locals()

        return comptxt

    def _get_comptxt_w_subparsers(self,subparsers):
        """
        Generates zsh autocompletion script if
        the script uses argparse subparsers.
        """
        cli_command = self.cli_command

        comptxt  = self._get_comptxt_header()
        comptxt += '_%(cli_command)s() {                         \n' % locals()
        comptxt += '    local context state line expl implementation \n'
        comptxt += '    local -a subcmds                             \n'
        comptxt += '                                                 \n'
        comptxt += '                                                 \n'
        comptxt += '    subcmds=( %s ) \n\n' % ' '.join([ subparser for subparser in subparsers ])

        comptxt += (
            "    _arguments -C                              \\\n"
            "        {-h,--help}'[show help information]'   \\\n"
            "        '1:subcommand:compadd -a subcmds'      \\\n"
            "        '*:: :->subcmd' && return                \n"
            "                                                 \n"
            "    service=\"$words[1]\"                        \n"
            "    curcontext=\"${curcontext%:*}-$service:\"    \n"
            "                                                 \n"
            "    case $service in                             \n"
            )
        for subparser in subparsers:
            comptxt +=(
                '    (%(title)s)                             \n'
                '        _arguments -A "-*"                \\\n'
            ) % subparsers[subparser]
            comptxt += self._parse_parser_args( indent=12, **subparsers[subparser] )

        comptxt +=(
            '    (*)\n'
            '        _message "unknown sub-command: $service" \n'
            '        ;;                                       \n'
            '    esac                                         \n'
            '}                                                \n'
            '                                                 \n'
            '_%(cli_command)s "$@"                            \n'
            ) % locals()


        return comptxt

    def _parse_parser_args(self, parser_instance, title=None, help=None, indent=0):
        """
        creates zsh '_arguments' line for each flag attached to a
        parser/subparser instance
        """
        completer_lines = []
        arguments       = parser_instance._actions

        for arg in arguments:
            completer_lines.append( self._parse_argument(arg) )
        completer_lines.append( ';;\n' )

        if indent:
            completer_lines = [ ' '*indent + line     for line in completer_lines ]


        ret = '\\\n'.join( completer_lines )

        return ret

    def _parse_argument(self,arg):
        """
        Writes a single zsh autocomp '_arguments' line.
        """

        flags = arg.option_strings
        help  = self._escape_argument_conts( arg.help )

        if len(flags) > 1:
            flagstr = ','.join(flags)
            argstr  = "{"+ flagstr +"}'["+ help +"]'"%locals()
        else:
            argstr = "'"+ flags[0]  +"["+ help +"]'".format(**locals())


        #self._parse_argument_nargs(arg)
        #self._parse_argument_datatype(arg)

        return argstr

    def _escape_argument_conts(self, string ):
        string = string.replace('\n',' ')
        string = string.replace("'", "\\'")
        string = string.replace("\\", "\\\\'")
        string = string.strip()
        return string

    def _parse_argument_nargs(self,arg):
        pass

    def _parse_argument_datatype(self,arg):
        pass


    def write(self,outfile=None):
        """
        __________________________________________________________________________________________________________________
        INPUT:
        __________________________________________________________________________________________________________________
        outfile | '/usr/share/zsh/functions/Completion/Unix/_myprogram' | (opt) | the location you'd like to write your
                |                                                       |       | zsh completer script to.
                |                                                       |       | (If not supplied, saves to current directory)
        """
        cli_command = self.cli_command

        ## find location of zsh autocompletion script
        if outfile:
            outfile = os.path.realpath(outfile)

        else:
            try:
                zsh_completer_dir = get_zsh_completer_dir()
            except( RuntimeError ):
                logger.warning(
                    'unable to find a valid location on your $fpath to install zsh autocompletion script to.\n'
                    'writing completer script to current directory'
                )
                zsh_completer_dir = ''
            outfile = '{zsh_completer_dir}_{cli_command}'.format(**loc())



        if not os.path.isdir( os.path.dirname(outfile) ):
            os.makedirs( os.path.dirname(outfile) )

        ## obtain and write autocomp
        comptxt     = self.get()
        with open( outfile, 'w' ) as fw:
            fw.write( comptxt )

        print('zsh autocompletion script written to: "%s"' % outfile )

        return comptxt



# =====
# Funcs
# =====

def get_zsh_completer_dir():
    """
    Using zsh, attempts to automatically locate the completion directory.
    (can be copied into setup.py to install your zsh autocompletion)

    __NOTE__:   http://zsh.sourceforge.net/Doc/Release/Completion-System.html#Completion-Directories
                The only generic completion directory that can be expected on all systems is 'Completion/Unix'
    """

    # ==================
    # find $fpath value
    # ==================
    success = True
    try:
        pipe = subprocess.Popen(['zsh','-c','echo $fpath'], stdout=PIPE, stderr=PIPE, universal_newlines=True )
    except:
        success = False

    (out,err) = pipe.communicate()
    if pipe.returncode != 0:
        success = False
        logger.error( out )
        if err:
            logger.error( err )
            raise RuntimeError('Error querying fpath from zsh')

    fpath = out.split(' ')

    # =======================================
    # look for Completion directory on $fpath
    # =======================================
    competion_path = None
    for path in fpath:
        if 'functions/Completion/Unix' in path:
            if os.path.isdir( path ):
                completion_path = path
                break

    if not completion_path:
        for path in fpath:
            if 'functions/Completion' in path:
                if os.path.isdir( path ):
                    completion_path = path
                    break

    if not completion_path:
        raise RuntimeError('Unable to find directory matching "*/functions/Completion" on $fpath')

    return completion_path



if __name__ == '__main__':
    get_zsh_completer_dir()
    pass





